'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var fs = require('fs-extra');
var debug = require('debug')('windows-build-tools');
var EventEmitter = require('events');

var _require = require('../utils/find-logfile'),
    findVCCLogFile = _require.findVCCLogFile;

var _require2 = require('../utils/installation-sucess'),
    includesSuccess = _require2.includesSuccess,
    includesFailure = _require2.includesFailure;

var Tailer = function (_EventEmitter) {
  _inherits(Tailer, _EventEmitter);

  function Tailer(logfile) {
    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';

    _classCallCheck(this, Tailer);

    var _this = _possibleConstructorReturn(this, (Tailer.__proto__ || Object.getPrototypeOf(Tailer)).call(this));

    _this.logFile = logfile;
    _this.encoding = encoding;
    return _this;
  }

  /**
   * Starts watching a the logfile
   */


  _createClass(Tailer, [{
    key: 'start',
    value: function start() {
      if (this.logFile) {
        debug('Tail: Waiting for log file to appear in ' + this.logFile);
      } else {
        debug('Tail: Waiting for log file to appear. Searching in %TEMP%');
      }
      this.waitForLogFile();
    }

    /**
     * Stop watching
     */

  }, {
    key: 'stop',
    value: function stop() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      debug.apply(undefined, ['Tail: Stopping'].concat(args));
      this.emit.apply(this, ['exit'].concat(args));
      clearInterval(this.tail);
    }

    /**
     * Start tailing things
     */

  }, {
    key: 'tail',
    value: function tail() {
      var _this2 = this;

      debug('Tail: Tailing ' + this.logFile);
      this.tail = setInterval(function () {
        _this2.handleData();
      }, 5000);
    }

    /**
     * Handle data and see if there's something we'd like to report
     */

  }, {
    key: 'handleData',
    value: function handleData() {
      var data = void 0;

      try {
        data = fs.readFileSync(this.logFile, this.encoding);
      } catch (err) {
        debug('Tail start: Could not read logfile ' + this.logFile + ': ' + err);
        return;
      }

      if (data && data.length > 0) {
        var split = data.split(/\r?\n/) || ['Still looking for log file...'];
        var lastLines = split.slice(split.length - 3, split.length);
        this.emit('lastLines', lastLines);
      }

      var success = includesSuccess(data);

      if (success.isBuildToolsSuccess) {
        debug('Tail: Reporting success for VCC Build Tools');
        this.stop('success');
      } else if (success.isPythonSuccess) {
        // Finding the python installation path from the log file
        var matches = data.match(/Property\(S\): TARGETDIR = (.*)\r\n/);
        var pythonPath = void 0;

        if (matches) {
          pythonPath = matches[1];
        }

        debug('Tail: Reporting success for Python');
        this.stop('success', pythonPath);
      } else if (includesFailure(data)) {
        debug('Tail: Reporting failure in ' + this.logFile);
        this.stop('failure');
      }

      // Aid garbage collector
      data = undefined;
    }

    /**
     * Waits for a given file, resolving when it's available
     *
     * @param file {string} - Path to file
     * @returns {Promise.<Object>} - Promise resolving with fs.stats object
     */

  }, {
    key: 'waitForLogFile',
    value: function waitForLogFile() {
      var _this3 = this;

      var handleStillWaiting = function handleStillWaiting() {
        debug('Tail: waitForFile: still waiting');
        setTimeout(_this3.waitForLogFile.bind(_this3), 2000);
      };

      var handleKnownPath = function handleKnownPath(logFile) {
        fs.lstat(logFile, function (err, stats) {
          if (err && err.code === 'ENOENT') {
            handleStillWaiting();
          } else if (err) {
            debug('Tail: waitForFile: Unexpected error', err);
            throw new Error(err);
          } else {
            debug('Tail: waitForFile: Found ' + logFile);
            _this3.tail();
          }
        });
      };

      // If don't have a logfile, we need to find one. The only one
      // we need to find right now is the VCC 2017 logfile.
      if (!this.logFile) {
        findVCCLogFile().then(function (logFile) {
          debug('Tail: LogFile found: ' + logFile);

          if (!logFile) {
            handleStillWaiting();
          } else {
            _this3.logFile = logFile;
            handleKnownPath(logFile);
          }
        });
      } else {
        handleKnownPath(this.logFile);
      }
    }
  }]);

  return Tailer;
}(EventEmitter);

module.exports = Tailer;